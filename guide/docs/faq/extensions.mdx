# Commands Extension

:::note

This is placeholder content that has been taken directly from the [documentation](https://docs.disnake.dev/en/latest/), and inherited from `discord.py`. This section will most likely be rewritten in the future.

:::

Questions regarding `disnake.ext.commands` belong here.

Why does `on_message` make my commands stop working?

```

Overriding the default provided ``on_message`` forbids any extra commands from running. To fix this, add a
``bot.process_commands(message)`` line at the end of your ``on_message``. For example: ::

    @bot.event
    async def on_message(message):
        # do some extra stuff here

        await bot.process_commands(message)

Alternatively, you can place your ``on_message`` logic into a **listener**. In this setup, you should not
manually call ``bot.process_commands()``. This also allows you to do multiple things asynchronously in response
to a message. Example::

    @bot.listen('on_message')
    async def whatever_you_want_to_call_it(message):
        # do stuff here
        # do not process commands here

Why do my arguments require quotes?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In a simple command defined as: ::

    @bot.command()
    async def echo(ctx, message: str):
        await ctx.send(message)

Calling it via ``?echo a b c`` will only fetch the first argument and disregard the rest. To fix this you should either call
it via ``?echo "a b c"`` or change the signature to have "consume rest" behaviour. Example: ::

    @bot.command()
    async def echo(ctx, *, message: str):
        await ctx.send(message)

This will allow you to use ``?echo a b c`` without needing the quotes.

How do I get the original ``message``\?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :class:`~ext.commands.Context` contains an attribute, :attr:`~.Context.message` to get the original
message.

Example: ::

    @bot.command()
    async def length(ctx):
        await ctx.send(f'Your message is {len(ctx.message.content)} characters long.')

How do I make a subcommand?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the :func:`~ext.commands.group` decorator. This will transform the callback into a :class:`~ext.commands.Group` which will allow you to add commands into
the group operating as "subcommands". These groups can be arbitrarily nested as well.

Example: ::

    @bot.group()
    async def git(ctx):
        if ctx.invoked_subcommand is None:
            await ctx.send('Invalid git command passed...')

    @git.command()
    async def push(ctx, remote: str, branch: str):
        await ctx.send(f'Pushing to {remote} {branch}')

This could then be used as ``?git push origin master``.
```
